//
//  DocumentViewController.swift
//  MotorImages
//
//  Created by iris on 05/07/20.
//  Copyright (c) 2020 iris. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import AVFoundation
protocol DocumentViewControllerDelegate: NSObjectProtocol{
	func displayCropView(viewModel: Documents.cropImageSend.ViewModel)
	func croppedFinished()
}
public protocol DocumentComunicacionExternaViewControllerDelegate : NSObjectProtocol {
	func captureDidFinishWithDocument(_ document: Document, captureVC: DocumentViewController)
	func captureDidCancel(captureVC: DocumentViewController)
}
open class DocumentViewController: UIViewController,DocumentViewControllerDelegate, AVCapturePhotoCaptureDelegate, UINavigationControllerDelegate{
	func croppedFinished() {
		router?.finishProcess()
	}
  var interactor: DocumentBusinessLogic?
  var router: (NSObjectProtocol & DocumentRoutingLogic & DocumentDataPassing)?
	@IBOutlet weak var viewForTakingPicture: UIImageView!
	@IBOutlet weak var imageLimit: UIImageView!
	@IBOutlet weak var instructionsLbl: UILabel!
	let stillImage = AVCapturePhotoOutput()
	private  let deviceOutput = AVCaptureVideoDataOutput()
	var imageLayer : CALayer = CALayer()
	var documentType: ProccessId = .documentDefault
	var doc: Document?
	var delegate: DocumentComunicacionExternaViewControllerDelegate?

	@IBOutlet weak var btonAction: UIButton!
	
	var session = AVCaptureSession()
  // MARK: Object lifecycle
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?){
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }
	required public init?(coder aDecoder: NSCoder){
    super.init(coder: aDecoder)
    setup()
  }
	
  // MARK: Setup
  
  private func setup()
  {
    let viewController = self
    let interactor = DocumentInteractor()
    let presenter = DocumentPresenter()
    let router = DocumentRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
	viewController.navigationController?.delegate = self
  }
  
  // MARK: View lifecycle
  
	open override func viewDidLoad(){
    super.viewDidLoad()
		let bundle = Bundle(for: DocumentViewController.self)
		switch documentType {
			case .anyDocument(documentLbl: let documentLbl):
				imageLimit.image = UIImage(named: "focusActaFrame", in: bundle, with: nil)
				instructionsLbl.text = "\(documentLbl)"
			case .documentDefault:
				imageLimit.image = UIImage(named: "focusActaFrame", in: bundle, with: nil)
				instructionsLbl.text = "Documento"
		}
		btonAction.setImage(UIImage(named: "image-2", in: bundle, compatibleWith: nil), for: .normal)
		configureSession()
		
  }
	open override func viewDidAppear(_ animated: Bool) {
		super.viewDidAppear(true)
	}
	open override func viewWillAppear(_ animated: Bool) {
		super.viewWillAppear(animated)
		navigationController?.setNavigationBarHidden(true, animated: false)
		startStream()
	}
  // MARK: Do something
  	func displayCropView(viewModel: Documents.cropImageSend.ViewModel) {
		router?.routeToCropView()
	}

	@IBAction func close(_ sender: Any) {
	 dismiss(animated: true, completion: nil)
	}
	
	@IBAction func takePicture(_ sender: Any) {
		let settings = AVCapturePhotoSettings()
		let previewPixelType = settings.availablePreviewPhotoPixelFormatTypes.first!
		let previewFormat = [kCVPixelBufferPixelFormatTypeKey as String: previewPixelType,
									kCVPixelBufferWidthKey as String: 160,
									kCVPixelBufferHeightKey as String: 160]
		settings.previewPhotoFormat = previewFormat
		stillImage.capturePhoto(with: settings, delegate: self)
	}
	public static func captureDocumentViewController(proccessId: ProccessId, client: Client? = nil, delegate vcDelegate: DocumentComunicacionExternaViewControllerDelegate) -> UINavigationController {
		let storyboardBundle = UIStoryboard(name: "DocumentCamera", bundle: Bundle(for: DocumentViewController.self))
		let vc = storyboardBundle.instantiateViewController(identifier: "captureVC") as! DocumentViewController
		vc.documentType = proccessId
		//vc.doc = Document(documentType: proccessId)
		vc.delegate = vcDelegate
		let navVC = UINavigationController(rootViewController: vc)
		navVC.modalPresentationStyle = .overFullScreen
		navVC.delegate = vc
		return navVC
	}
	public func navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) {
		if let documentVC = viewController as? DocumentViewController{
			documentVC.interactor?.fetchCropped()
		}
	}
	
}
extension DocumentViewController{
	func configureSession(){
		session.sessionPreset = AVCaptureSession.Preset.photo
		guard let captureDevice = AVCaptureDevice.default(for: AVMediaType.video) else{return}
		let deviceInput = try! AVCaptureDeviceInput(device: captureDevice)
		if(captureDevice.isFocusModeSupported(.continuousAutoFocus)) {
			try! captureDevice.lockForConfiguration()
			captureDevice.focusMode = .continuousAutoFocus
			captureDevice.unlockForConfiguration()
		}
		if captureDevice.hasTorch{
			do{
				try captureDevice.lockForConfiguration()
				captureDevice.torchMode = .auto
				captureDevice.unlockForConfiguration()
			}catch{
				print("torch couldnÂ´t be used")
			}
		}
		self.session.addInput(deviceInput)
		self.session.addOutput(deviceOutput)
		session.addOutput(stillImage)
		session.sessionPreset = .photo
		imageLayer = AVCaptureVideoPreviewLayer(session: session)
	}
	func startStream() {
		imageLayer.frame = viewForTakingPicture.bounds
		viewForTakingPicture.layer.addSublayer(imageLayer)
		session.startRunning()
	}
}
extension DocumentViewController{
	public func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
		let imageData = photo.fileDataRepresentation()
		if let data = imageData, let _ = UIImage(data: data) {
			
			DispatchQueue.main.async {
				let ciImage = CIImage(data: data)!.oriented(CGImagePropertyOrientation.right)
				let context = CIContext()
				let originalImageCG = context.createCGImage(ciImage, from: ciImage.extent)
				let originalImage = UIImage(ciImage: ciImage)
				let request = Documents.cropImageSend.Request(originalImage: originalImage, originalImageCG: originalImageCG!)
				self.interactor?.saveOriginalImage(request: request)
				self.router?.routeToCropView()
			}
		}
	}
}

